{"version":3,"file":"tooltip.js","sourceRoot":"","sources":["../../../src/components/tooltip/tooltip.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, ComponentInterface, h, Host, Prop, Element, Watch, Method } from '@stencil/core';\nimport { WcsTooltipAppendTo, WcsTooltipPosition } from './tooltip-interface';\n\n// We use the Tippy.js library for the tooltip. At first by using directly the styles of tippy because\n// the design system does not specify any spec for the tooltips.\n//\n// In a second time, if a need of customization is felt, it will be possible to use the lib in a\n// \"Headless\" mode where the rendering of the tooltip will be entirely in our charge, without\n// modifications in the API : https://atomiks.github.io/tippyjs/v6/headless-tippy/\nimport tippy, { Instance, Props } from 'tippy.js';\n\n/**\n * Tooltips are used to provide additional information for features available on the website. These can improve the user\n * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them\n * (for longer content).\n *\n * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/\n */\n@Component({\n    tag: 'wcs-tooltip',\n    shadow: true,\n    // Tippy stylesheet and specific styles are imported in the global tooltip.scss file\n    styleUrl: 'tooltip.scss'\n})\nexport class Tooltip implements ComponentInterface {\n    /**\n     * The **id** of the element the tooltip's going to describe.\n     *\n     * This property cannot be modified after initialization.\n     *\n     * @example\n     * ```html\n     * <span id=\"tooltiped\">Some content</span>\n     * <wcs-tooltip for=\"tooltiped\">A tooltip!</wcs-tooltip>\n     * ```\n     */\n    @Prop({mutable: false})\n    for: string;\n\n    /**\n     * Where the tooltip is going to show relative to the element it's describing.\n     */\n    @Prop({reflect: true})\n    position: WcsTooltipPosition = 'bottom';\n\n    /**\n     * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside\n     * without hiding.\n     */\n    @Prop()\n    interactive: boolean = false;\n\n    /**\n     * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.\n     *\n     * If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.\n     */\n    @Prop()\n    maxWidth: string | number = 350;\n\n    /**\n     * Delay in ms once a trigger event is fired before the tooltip shows or hides.\n     *\n     * You can provide an array with two values to define a different duration for show and hide.\n     *\n     * `[showDelay, hideDelay]`\n     *\n     * Use null to use default value.\n     */\n    @Prop()\n    delay: number | [number, number] = 0;\n\n    /**\n     * Duration in ms of the transition animation.\n     */\n    @Prop()\n    duration: number | [number, number] = [300, 250];\n\n    /**\n     * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.\n     *\n     * See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger\n     */\n    @Prop()\n    trigger: string = 'mouseenter focus';\n\n    /**\n     * Allows you to change the theme used by tippy.\n     *\n     * The WCS theme is used by default and uses the WCS CSS variables.\n     *\n     * You can create a theme by following this documentation and choosing a custom name :\n     * https://atomiks.github.io/tippyjs/v6/themes/\n     */\n    @Prop()\n    theme: string = 'wcs';\n\n    /**\n     * You can use this property instead of the slot API to affect content in the tooltip.\n     *\n     * This makes it easier to manage the update if the tooltip contains elements that are not mutated when their\n     * content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM\n     * changes (the DOM must be mutated).\n     *\n     * The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first\n     * display the content of this property and then the slotted elements.\n     */\n    @Prop()\n    content: string;\n\n    /**\n     * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true,\n     * the default behavior is appendTo: \"parent\"\n     *\n     * See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto\n     */\n    @Prop()\n    appendTo: WcsTooltipAppendTo;\n\n    @Element()\n    private el: HTMLWcsTooltipElement;\n\n    private tippyInstance: Instance<Props>;\n\n    componentWillLoad(): Promise<void> | void {\n        this.tippyInstance = tippy(document.getElementById(this.for), {\n            appendTo: this.appendTo || (() => document.body),\n            theme: this.theme,\n            allowHTML: true,\n            content: this.getTooltipContentFromPropAndSlot(),\n            maxWidth: this.maxWidth,\n            placement: this.position,\n            delay: this.delay,\n            duration: this.duration,\n            interactive: this.interactive,\n            trigger: this.trigger\n        });\n    }\n\n    private getTooltipContentFromPropAndSlot() {\n        if (this.content) {\n            return this.content + this.el.innerHTML;\n        }\n        return this.el.innerHTML;\n    }\n\n    @Watch('interactive')\n    @Watch('position')\n    @Watch('maxWidth')\n    @Watch('theme')\n    @Watch('delay')\n    @Watch('duration')\n    @Watch('trigger')\n    // @ts-ignore\n    private updateProps() {\n        this.tippyInstance?.setProps({\n            interactive: this.interactive,\n            placement: this.position,\n            maxWidth: this.maxWidth,\n            theme: this.theme,\n            delay: this.delay,\n            duration: this.duration,\n            trigger: this.trigger\n        })\n    }\n\n    @Watch('content')\n    private updateTippyContent() {\n        this.tippyInstance?.setProps({\n            content: this.getTooltipContentFromPropAndSlot()\n        })\n    }\n\n    /**\n     * Programmatically hide the tooltip\n     */\n    @Method()\n    async hide() {\n        this.tippyInstance.hide();\n    }\n\n    /**\n     * Programmatically show the tooltip\n     */\n    @Method()\n    async show() {\n        this.tippyInstance.show();\n    }\n\n    /**\n     * Temporarily prevent the tooltip from showing or hiding\n     */\n    @Method()\n    async disable() {\n        this.tippyInstance.disable();\n    }\n\n    /**\n     * Re-enable a disabled tooltip\n     */\n    @Method()\n    async enable() {\n        this.tippyInstance.enable();\n    }\n\n    disconnectedCallback() {\n        this.tippyInstance?.destroy();\n    }\n\n    render() {\n        return (\n            <Host>\n                <slot onSlotchange={_ => this.updateTippyContent()}/>\n            </Host>\n        );\n    }\n\n\n}\n"]}