{"version":3,"names":["tabsCss","Tabs","selectedIndexChanged","newValue","this","currentActiveTabIndex","selectedTabkeyChanged","updateCurrentActiveIndexByTabKey","emitActiveTabChange","tabChange","emit","tabName","headers","tabIndex","selectedKey","tabs","itemKey","i","length","tab","onTabLoaded","refreshHeaders","componentDidLoad","putTabsInCorrectDivIfTheyAreNot","selectedIndex","tabDiv","el","shadowRoot","querySelector","Array","from","querySelectorAll","filter","node","parentNode","forEach","parentElement","isEqualNode","removeChild","appendChild","handleKeyDown","ev","target","key","preventDefault","_a","previousElementSibling","classList","contains","focus","_b","nextElementSibling","x","push","getAttribute","tabsEl","assignedElements","selectTabAndEmitChangeEvent","index","componentWillUpdate","headersOnly","updateTabVisibility","hideAllTabsContent","idx","setAttribute","render","h","Host","class","map","header","onClick","onKeyDown","evt","name"],"sources":["./src/components/tabs/tabs.scss?tag=wcs-tabs&encapsulation=shadow","./src/components/tabs/tabs.tsx"],"sourcesContent":["@import '../../style/focus-outline.scss';\n\n:host {\n    --wcs-tabs-padding-bottom: 16px;\n}\n\n:host([align=start]) .wcs-tabs-headers {\n    justify-content: start;\n}\n\n:host([align=end]) .wcs-tabs-headers {\n    justify-content: end;\n}\n\n:host([align=center]) .wcs-tabs-headers {\n    justify-content: center;\n}\n\n.wcs-tabs-headers {\n    padding-top: 4px;\n    overflow-x: auto;\n    display: flex;\n    position: relative;\n}\n\n:host([gutter]) {\n    .wcs-tabs-headers {\n        border-bottom: var(--wcs-tabs-headers-border-bottom);\n    }\n}\n\n.wcs-tab-header {\n    padding: 8px 24px 16px 0;\n    display: flex;\n    flex-shrink: 0;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    outline: none;\n\n    span {\n        text-align: center;\n        color: var(--wcs-text-disabled);\n        font-size: 1rem;\n        font-weight: 400;\n    }\n\n\n    &:focus,\n    &:hover {\n        span {\n            color: var(--wcs-primary);\n        }\n    }\n\n    &:focus-visible > span {\n        @include focus-outline;\n    }\n}\n\n\n.active {\n    span {\n        font-weight: 500;\n        color: var(--wcs-primary);\n        position: relative;\n    }\n\n    span::after {\n        position: absolute;\n        bottom: calc(var(--wcs-tabs-padding-bottom) * -1);\n        left: 0;\n        width: 100%;\n        height: 0.3125rem;\n        content: \"\";\n        background-color: var(--wcs-primary);\n        border-radius: 3px;\n    }\n}\n","import {\n    Component,\n    Prop,\n    Element,\n    State,\n    ComponentInterface,\n    Event,\n    EventEmitter,\n    Watch,\n    h,\n    Host,\n    Listen\n} from '@stencil/core';\n\nimport { WcsTabsAlignment, WcsTabChangeEvent } from './tabs-interface';\n\n/**\n * Tabs component to switch between tab content.\n * Use in conjuction with `wcs-tab`.\n *\n * @example\n * ```html\n * <wcs-tabs>\n *    <wcs-tab header=\"One\">The content !</wcs-tab>\n *    <wcs-tab header=\"Two\">More content !</wcs-tab>\n * </wcs-tabs>\n * ```\n */\n@Component({\n    tag: 'wcs-tabs',\n    styleUrl: 'tabs.scss',\n    shadow: true,\n})\nexport class Tabs implements ComponentInterface {\n    /**\n     * Tab headers alignment.\n     */\n    @Prop({reflect: true}) align: WcsTabsAlignment = 'start';\n\n    /**\n     * Current selected tab index.\n     * Starts at 0.\n     */\n    @Prop() selectedIndex: number = 0;\n\n    @Prop() selectedKey: any;\n\n    /**\n     * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to\n     * separately render the tab content.\n     */\n    @Prop() headersOnly: boolean = false;\n    /** Determines if tabs header should have a border at the bottom */\n    @Prop() gutter: boolean;\n\n    /**\n     *\n     * Emitted when the selected tab change.\n     */\n    @Event() tabChange!: EventEmitter<WcsTabChangeEvent>;\n\n    @Element() private el!: HTMLWcsTabsElement;\n\n    @State() private headers: string[] = [];\n\n    @State() private currentActiveTabIndex = 0;\n\n    @Watch('selectedIndex')\n    selectedIndexChanged(newValue: number) {\n        this.currentActiveTabIndex = newValue;\n    }\n\n    @Watch('selectedKey')\n    selectedTabkeyChanged(newValue: any) {\n        this.updateCurrentActiveIndexByTabKey(newValue);\n    }\n\n    private emitActiveTabChange() {\n        this.tabChange.emit({\n            tabName: this.headers[this.currentActiveTabIndex],\n            tabIndex: this.currentActiveTabIndex,\n            selectedKey: this.tabs[this.currentActiveTabIndex].itemKey\n        });\n    }\n\n    private updateCurrentActiveIndexByTabKey(newValue: any) {\n        for (let i = 0; i < this.tabs.length; i++) {\n            const tab = this.tabs[i];\n            if (tab.itemKey === newValue) {\n                this.currentActiveTabIndex = i;\n            }\n        }\n    }\n\n    @Listen('tabLoaded')\n    onTabLoaded() {\n        this.refreshHeaders();\n    }\n\n    componentDidLoad() {\n        this.putTabsInCorrectDivIfTheyAreNot();\n        this.refreshHeaders();\n        if (this.selectedIndex) {\n            this.currentActiveTabIndex = this.selectedIndex;\n        }\n        if (this.selectedKey) {\n            this.updateCurrentActiveIndexByTabKey(this.selectedKey);\n        }\n    }\n\n    // XXX: Firefox < 63\n    private putTabsInCorrectDivIfTheyAreNot() {\n        const tabDiv = this.el.shadowRoot.querySelector('.wcs-tabs');\n        if (tabDiv.querySelector('slot') === null) {\n            Array.from(this.el.querySelectorAll('wcs-tab'))\n                .filter(node => node.parentNode !== tabDiv)\n                .forEach(tab => {\n                    if (tab.parentElement.isEqualNode(this.el)) {\n                        this.el.removeChild(tab);\n                        tabDiv.appendChild(tab);\n                    }\n                });\n        }\n    }\n\n    handleKeyDown(ev: KeyboardEvent, tabIndex: number) {\n        const target = ev.target as HTMLDivElement;\n        switch (ev.key) {\n            case ' ':\n            case 'Enter': {\n                this.currentActiveTabIndex = tabIndex;\n                this.emitActiveTabChange();\n                ev.preventDefault();\n                break;\n            }\n            case 'ArrowLeft': {\n                if (target.previousElementSibling?.classList.contains('wcs-tab-header')) {\n                    (target.previousElementSibling as HTMLDivElement).focus();\n                    ev.preventDefault();\n                }\n                break;\n            }\n            case 'ArrowRight': {\n                if (target.nextElementSibling?.classList.contains('wcs-tab-header')) {\n                    (target.nextElementSibling as HTMLDivElement).focus();\n                    ev.preventDefault();\n                }\n                break;\n            }\n        }\n    }\n\n    private refreshHeaders() {\n        this.headers = [];\n        this.tabs\n            .forEach(x => {\n                this.headers.push(x.getAttribute('header'));\n            });\n    }\n\n    private get tabs() {\n        const tabsEl = this.el.shadowRoot.querySelector('.wcs-tabs');\n        // FIXME: problem with this selector being too greedy in ff < 63\n        const tabs = this.el.shadowRoot.querySelectorAll('.wcs-tabs > wcs-tab');\n\n        return tabs.length !== 0\n            ? tabs\n            : tabsEl?.querySelector('slot')\n                ? tabsEl?.querySelector('slot')?.assignedElements() as unknown as NodeListOf<HTMLWcsTabElement>\n                : [];\n    }\n\n    private selectTabAndEmitChangeEvent(index: number) {\n        this.currentActiveTabIndex = index;\n        this.emitActiveTabChange()\n    }\n\n    componentWillUpdate() {\n        if (!this.headersOnly) {\n            this.updateTabVisibility();\n        } else {\n            this.hideAllTabsContent();\n        }\n    }\n\n    private updateTabVisibility() {\n        this.tabs.forEach((el: HTMLWcsTabElement, idx: number) => {\n            if (idx !== this.currentActiveTabIndex) {\n                el.setAttribute('style', 'display: none;');\n            } else {\n                el.setAttribute('style', 'display: block;');\n            }\n        });\n    }\n\n    private hideAllTabsContent() {\n        this.tabs.forEach((el: HTMLWcsTabElement) => el.setAttribute('style', 'display: none;'));\n    }\n\n    render() {\n        return (\n            <Host>\n                <div class=\"wcs-tabs-headers\">\n                    {this.headers.map((header, idx) =>\n                        <div class={'wcs-tab-header ' + (this.currentActiveTabIndex === idx ? 'active' : '')}\n                             onClick={() => this.selectTabAndEmitChangeEvent(idx)}\n                             onKeyDown={evt => this.handleKeyDown(evt, idx)}\n                             tabIndex={this.currentActiveTabIndex === idx ? 0 : -1}\n                        >\n                            <span>{header}</span>\n                        </div>\n                    )}\n                </div>\n                <div class=\"wcs-tabs\">\n                    <slot name=\"wcs-tab\"/>\n                </div>\n            </Host>\n        );\n    }\n}\n"],"mappings":"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"}